"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1090],{21090:function(e,n,s){s.d(n,{mL:function(){return m},CL:function(){return a},zd:function(){return u}});var o=s(38966),i=s.n(o),t=JSON.parse('{"Sw":{"D":"fn main() {\\n    // It is necessary to call this function once. Otherwise some patches to the runtime\\n    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71\\n    esp_idf_svc::sys::link_patches();\\n\\n    // Bind the log crate to the ESP Logging facilities\\n    esp_idf_svc::log::EspLogger::initialize_default();\\n\\n    log::info!(\\"Hello world!\\");\\n}\\n","s":"[package]\\nname = \\"rust-project-esp32\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nresolver = \\"2\\"\\nrust-version = \\"1.71\\"\\n\\n[profile.release]\\nopt-level = \\"s\\"\\ndebug = true    # Symbols are nice and they don\'t increase the size on Flash\\n\\n[features]\\ndefault = [\\"std\\", \\"embassy\\", \\"esp-idf-svc/native\\"]\\n\\nstd = [\\"esp-idf-svc/alloc\\", \\"esp-idf-svc/binstart\\", \\"esp-idf-svc/std\\"]\\nembassy = [\\"esp-idf-svc/embassy-sync\\", \\"esp-idf-svc/critical-section\\", \\"esp-idf-svc/embassy-time-driver\\"]\\n\\n[dependencies]\\nlog = { version = \\"0.4\\", default-features = false }\\nesp-idf-svc = { version = \\"0.48.1\\", default-features = false }\\n\\n[build-dependencies]\\nembuild = \\"0.31.4\\"\\n"},"yV":{"D":"fn main() {\\n    // It is necessary to call this function once. Otherwise some patches to the runtime\\n    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71\\n    esp_idf_svc::sys::link_patches();\\n\\n    // Bind the log crate to the ESP Logging facilities\\n    esp_idf_svc::log::EspLogger::initialize_default();\\n\\n    log::info!(\\"Hello world!\\");\\n}\\n","s":"[package]\\nname = \\"rust-project-esp32c3\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nresolver = \\"2\\"\\nrust-version = \\"1.71\\"\\n\\n[profile.release]\\nopt-level = \\"s\\"\\n\\n[profile.dev]\\ndebug = true    # Symbols are nice and they don\'t increase the size on Flash\\nopt-level = \\"z\\"\\n\\n[features]\\ndefault = [\\"std\\", \\"embassy\\", \\"esp-idf-svc/native\\"]\\n\\npio = [\\"esp-idf-svc/pio\\"]\\nstd = [\\"alloc\\", \\"esp-idf-svc/binstart\\", \\"esp-idf-svc/std\\"]\\nalloc = [\\"esp-idf-svc/alloc\\"]\\nnightly = [\\"esp-idf-svc/nightly\\"]\\nexperimental = [\\"esp-idf-svc/experimental\\"]\\nembassy = [\\"esp-idf-svc/embassy-sync\\", \\"esp-idf-svc/critical-section\\", \\"esp-idf-svc/embassy-time-driver\\"]\\n\\n[dependencies]\\nlog = { version = \\"0.4\\", default-features = false }\\nesp-idf-svc = { version = \\"0.47.1\\", default-features = false }\\n\\n[build-dependencies]\\nembuild = \\"0.31.3\\"\\n"},"cq":{"D":"fn main() {\\n    // It is necessary to call this function once. Otherwise some patches to the runtime\\n    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71\\n    esp_idf_svc::sys::link_patches();\\n\\n    // Bind the log crate to the ESP Logging facilities\\n    esp_idf_svc::log::EspLogger::initialize_default();\\n\\n    log::info!(\\"Hello world!\\");\\n}\\n","s":"[package]\\nname = \\"rust-project-esp32s2\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nresolver = \\"2\\"\\nrust-version = \\"1.71\\"\\n\\n[profile.release]\\nopt-level = \\"s\\"\\n\\n[profile.dev]\\ndebug = true    # Symbols are nice and they don\'t increase the size on Flash\\nopt-level = \\"z\\"\\n\\n[features]\\ndefault = [\\"std\\", \\"embassy\\", \\"esp-idf-svc/native\\"]\\n\\npio = [\\"esp-idf-svc/pio\\"]\\nstd = [\\"alloc\\", \\"esp-idf-svc/binstart\\", \\"esp-idf-svc/std\\"]\\nalloc = [\\"esp-idf-svc/alloc\\"]\\nnightly = [\\"esp-idf-svc/nightly\\"]\\nexperimental = [\\"esp-idf-svc/experimental\\"]\\nembassy = [\\"esp-idf-svc/embassy-sync\\", \\"esp-idf-svc/critical-section\\", \\"esp-idf-svc/embassy-time-driver\\"]\\n\\n[dependencies]\\nlog = { version = \\"0.4\\", default-features = false }\\nesp-idf-svc = { version = \\"0.47.1\\", default-features = false }\\n\\n[build-dependencies]\\nembuild = \\"0.31.3\\"\\n"},"U6":{"D":"fn main() {\\n    // It is necessary to call this function once. Otherwise some patches to the runtime\\n    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71\\n    esp_idf_svc::sys::link_patches();\\n\\n    // Bind the log crate to the ESP Logging facilities\\n    esp_idf_svc::log::EspLogger::initialize_default();\\n\\n    log::info!(\\"Hello world!\\");\\n}\\n","s":"[package]\\nname = \\"rust-project-esp32s3\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nresolver = \\"2\\"\\nrust-version = \\"1.71\\"\\n\\n[profile.release]\\nopt-level = \\"s\\"\\n\\n[profile.dev]\\ndebug = true    # Symbols are nice and they don\'t increase the size on Flash\\nopt-level = \\"z\\"\\n\\n[features]\\ndefault = [\\"std\\", \\"embassy\\", \\"esp-idf-svc/native\\"]\\n\\npio = [\\"esp-idf-svc/pio\\"]\\nstd = [\\"alloc\\", \\"esp-idf-svc/binstart\\", \\"esp-idf-svc/std\\"]\\nalloc = [\\"esp-idf-svc/alloc\\"]\\nnightly = [\\"esp-idf-svc/nightly\\"]\\nexperimental = [\\"esp-idf-svc/experimental\\"]\\nembassy = [\\"esp-idf-svc/embassy-sync\\", \\"esp-idf-svc/critical-section\\", \\"esp-idf-svc/embassy-time-driver\\"]\\n\\n[dependencies]\\nlog = { version = \\"0.4\\", default-features = false }\\nesp-idf-svc = { version = \\"0.47.1\\", default-features = false }\\n\\n[build-dependencies]\\nembuild = \\"0.31.3\\"\\n"},"_y":{"D":"fn main() {\\n    // It is necessary to call this function once. Otherwise some patches to the runtime\\n    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71\\n    esp_idf_svc::sys::link_patches();\\n\\n    // Bind the log crate to the ESP Logging facilities\\n    esp_idf_svc::log::EspLogger::initialize_default();\\n\\n    log::info!(\\"Hello world!\\");\\n}\\n","s":"[package]\\nname = \\"rust-project-esp32c3\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nresolver = \\"2\\"\\nrust-version = \\"1.71\\"\\n\\n[profile.release]\\nopt-level = \\"s\\"\\n\\n[profile.dev]\\ndebug = true    # Symbols are nice and they don\'t increase the size on Flash\\nopt-level = \\"z\\"\\n\\n[features]\\ndefault = [\\"std\\", \\"embassy\\", \\"esp-idf-svc/native\\"]\\n\\npio = [\\"esp-idf-svc/pio\\"]\\nstd = [\\"alloc\\", \\"esp-idf-svc/binstart\\", \\"esp-idf-svc/std\\"]\\nalloc = [\\"esp-idf-svc/alloc\\"]\\nnightly = [\\"esp-idf-svc/nightly\\"]\\nexperimental = [\\"esp-idf-svc/experimental\\"]\\nembassy = [\\"esp-idf-svc/embassy-sync\\", \\"esp-idf-svc/critical-section\\", \\"esp-idf-svc/embassy-time-driver\\"]\\n\\n[dependencies]\\nlog = { version = \\"0.4\\", default-features = false }\\nesp-idf-svc = { version = \\"0.47.1\\", default-features = false }\\n\\n[build-dependencies]\\nembuild = \\"0.31.3\\"\\n"},"Yg":{"D":"#![no_std]\\n#![no_main]\\n\\nuse esp_backtrace as _;\\nuse esp_println::println;\\nuse esp_hal::{clock::ClockControl, peripherals::Peripherals, prelude::*, Delay};\\n\\n#[entry]\\nfn main() -> ! {\\n    let peripherals = Peripherals::take();\\n    let system = peripherals.SYSTEM.split();\\n    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();\\n    let mut delay = Delay::new(&clocks);\\n\\n    println!(\\"Hello world!\\");\\n\\n    loop {\\n        println!(\\"Loop...\\");\\n        delay.delay_ms(500u32);\\n    }\\n}\\n","s":"[package]\\nname = \\"rust_project_esp32\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nlicense = \\"MIT OR Apache-2.0\\"\\n\\n[dependencies]\\nesp-hal = { version = \\"0.16.0\\", features = [\\"esp32\\"] }\\nesp-backtrace = { version = \\"0.11.1\\", features = [\\n    \\"esp32\\",\\n    \\"panic-handler\\",\\n    \\"println\\",\\n] }\\nesp-println = { version = \\"0.9.0\\", features = [\\"esp32\\"] }\\n\\n"},"v3":{"D":"#![no_std]\\n#![no_main]\\n\\nuse esp_backtrace as _;\\nuse esp_println::println;\\nuse esp_hal::{clock::ClockControl, peripherals::Peripherals, prelude::*, Delay};\\n\\n#[entry]\\nfn main() -> ! {\\n    let peripherals = Peripherals::take();\\n    let system = peripherals.SYSTEM.split();\\n    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();\\n    let mut delay = Delay::new(&clocks);\\n\\n    println!(\\"Hello world!\\");\\n\\n    loop {\\n        println!(\\"Loop...\\");\\n        delay.delay_ms(500u32);\\n    }\\n}\\n","s":"[package]\\nname = \\"rust_project_esp32c3\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nlicense = \\"MIT OR Apache-2.0\\"\\n\\n[dependencies]\\nesp-hal = { version = \\"0.16.0\\", features = [\\"esp32c3\\"] }\\nesp-backtrace = { version = \\"0.11.1\\", features = [\\n    \\"esp32c3\\",\\n    \\"panic-handler\\",\\n    \\"exception-handler\\",\\n    \\"println\\",\\n] }\\nesp-println = { version = \\"0.9.0\\", features = [\\"esp32c3\\"] }\\n"},"Gm":{"D":"#![no_std]\\n#![no_main]\\n\\nuse esp_backtrace as _;\\nuse esp_println::println;\\nuse esp_hal::{clock::ClockControl, peripherals::Peripherals, prelude::*, Delay};\\n\\n#[entry]\\nfn main() -> ! {\\n    let peripherals = Peripherals::take();\\n    let system = peripherals.SYSTEM.split();\\n    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();\\n    let mut delay = Delay::new(&clocks);\\n\\n    println!(\\"Hello world!\\");\\n\\n    loop {\\n        println!(\\"Loop...\\");\\n        delay.delay_ms(500u32);\\n    }\\n}\\n","s":"[package]\\nname = \\"rust_project_esp32s2\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nlicense = \\"MIT OR Apache-2.0\\"\\n\\n[dependencies]\\nesp-hal = { version = \\"0.16.0\\", features = [\\"esp32s2\\"] }\\nesp-backtrace = { version = \\"0.11.1\\", features = [\\n    \\"esp32s2\\",\\n    \\"panic-handler\\",\\n    \\"exception-handler\\",\\n    \\"println\\",\\n] }\\nesp-println = { version = \\"0.9.0\\", features = [\\"esp32s2\\"] }\\n"},"Hs":{"D":"#![no_std]\\n#![no_main]\\n\\nuse esp_backtrace as _;\\nuse esp_println::println;\\nuse esp_hal::{clock::ClockControl, peripherals::Peripherals, prelude::*, Delay};\\n\\n#[entry]\\nfn main() -> ! {\\n    let peripherals = Peripherals::take();\\n    let system = peripherals.SYSTEM.split();\\n    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();\\n    let mut delay = Delay::new(&clocks);\\n\\n    println!(\\"Hello world!\\");\\n\\n    loop {\\n        println!(\\"Loop...\\");\\n        delay.delay_ms(500u32);\\n    }\\n}\\n","s":"[package]\\nname = \\"rust_project_esp32s3\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nlicense = \\"MIT OR Apache-2.0\\"\\n\\n[dependencies]\\nesp-hal = { version = \\"0.16.0\\", features = [\\"esp32s3\\"] }\\nesp-backtrace = { version = \\"0.11.1\\", features = [\\n    \\"esp32s3\\",\\n    \\"panic-handler\\",\\n    \\"exception-handler\\",\\n    \\"println\\",\\n] }\\nesp-println = { version = \\"0.9.0\\", features = [\\"esp32s3\\"] }\\n\\n"},"Im":{"D":"#![no_std]\\n#![no_main]\\n\\nuse esp_backtrace as _;\\nuse esp_println::println;\\nuse esp_hal::{clock::ClockControl, peripherals::Peripherals, prelude::*, Delay};\\n\\n#[entry]\\nfn main() -> ! {\\n    let peripherals = Peripherals::take();\\n    let system = peripherals.SYSTEM.split();\\n    let clocks = ClockControl::boot_defaults(system.clock_control).freeze();\\n    let mut delay = Delay::new(&clocks);\\n\\n    println!(\\"Hello world!\\");\\n\\n    loop {\\n        println!(\\"Loop...\\");\\n        delay.delay_ms(500u32);\\n    }\\n}\\n","s":"[package]\\nname = \\"rust_project_esp32c3\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Sergio Gasquez <sergio.gasquez@gmail.com>\\"]\\nedition = \\"2021\\"\\nlicense = \\"MIT OR Apache-2.0\\"\\n\\n[dependencies]\\nesp-hal = { version = \\"0.16.0\\", features = [\\"esp32c3\\"] }\\nesp-backtrace = { version = \\"0.11.1\\", features = [\\n    \\"esp32c3\\",\\n    \\"panic-handler\\",\\n    \\"exception-handler\\",\\n    \\"println\\",\\n] }\\nesp-println = { version = \\"0.9.0\\", features = [\\"esp32c3\\"] }\\n"},"hP":{"D":"#![no_std]\\n#![no_main]\\n\\nuse panic_halt as _;\\n\\n#[arduino_hal::entry]\\nfn main() -> ! {\\n    let dp = arduino_hal::Peripherals::take().unwrap();\\n    let pins = arduino_hal::pins!(dp);\\n\\n    let mut led = pins.d13.into_output();\\n\\n    loop {\\n        led.toggle();\\n        arduino_hal::delay_ms(1000);\\n    }\\n}\\n\\n","s":"[package]\\nname = \\"rust-avr-mega\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Frederick Vollbrecht<frederick@vollbrecht.cc>\\"]\\nedition = \\"2021\\"\\nlicense = \\"MIT OR Apache-2.0\\"\\n\\n[[bin]]\\nname = \\"rust-avr-mega\\"\\ntest = false\\nbench = false\\n\\n[dependencies]\\npanic-halt = \\"0.2.0\\"\\nufmt = \\"0.1.0\\"\\nnb = \\"0.1.2\\"\\nembedded-hal = \\"0.2.3\\"\\n\\n[dependencies.arduino-hal]\\ngit = \\"https://github.com/rahix/avr-hal\\"\\nrev = \\"7dfa6d322b9df98b2d98afe0e14a97afe0187ac1\\"\\nfeatures = [\\"arduino-mega2560\\"]\\n\\n# Configure the build for minimal size - AVRs have very little program memory\\n[profile.release]\\npanic = \\"abort\\"\\ncodegen-units = 1\\ndebug = true\\nlto = true\\nopt-level = \\"s\\"\\n"},"Ui":{"D":"#![no_std]\\n#![no_main]\\n\\nuse panic_halt as _;\\n\\n#[arduino_hal::entry]\\nfn main() -> ! {\\n    let dp = arduino_hal::Peripherals::take().unwrap();\\n    let pins = arduino_hal::pins!(dp);\\n\\n    let mut led = pins.d13.into_output();\\n\\n    loop {\\n        led.toggle();\\n        arduino_hal::delay_ms(1000);\\n    }\\n}\\n","s":"[package]\\nname = \\"rust-avr-nano\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Frederick Vollbrecht<frederick@vollbrecht.cc>\\"]\\nedition = \\"2021\\"\\nlicense = \\"MIT OR Apache-2.0\\"\\n\\n[[bin]]\\nname = \\"rust-avr-nano\\"\\ntest = false\\nbench = false\\n\\n[dependencies]\\npanic-halt = \\"0.2.0\\"\\nufmt = \\"0.1.0\\"\\nnb = \\"0.1.2\\"\\nembedded-hal = \\"0.2.3\\"\\n\\n[dependencies.arduino-hal]\\ngit = \\"https://github.com/rahix/avr-hal\\"\\nrev = \\"7dfa6d322b9df98b2d98afe0e14a97afe0187ac1\\"\\nfeatures = [\\"arduino-nano\\"]\\n\\n# Configure the build for minimal size - AVRs have very little program memory\\n[profile.release]\\npanic = \\"abort\\"\\ncodegen-units = 1\\ndebug = true\\nlto = true\\nopt-level = \\"s\\"\\n"},"xE":{"D":"#![no_std]\\n#![no_main]\\n\\nuse panic_halt as _;\\n\\n#[arduino_hal::entry]\\nfn main() -> ! {\\n    let dp = arduino_hal::Peripherals::take().unwrap();\\n    let pins = arduino_hal::pins!(dp);\\n\\n    let mut led = pins.d13.into_output();\\n\\n    loop {\\n        led.toggle();\\n        arduino_hal::delay_ms(1000);\\n    }\\n}\\n","s":"[package]\\nname = \\"rust-avr-uno\\"\\nversion = \\"0.1.0\\"\\nauthors = [\\"Frederick Vollbrecht<frederick@vollbrecht.cc>\\"]\\nedition = \\"2021\\"\\nlicense = \\"MIT OR Apache-2.0\\"\\n\\n[[bin]]\\nname = \\"rust-avr-uno\\"\\ntest = false\\nbench = false\\n\\n[dependencies]\\npanic-halt = \\"0.2.0\\"\\nufmt = \\"0.1.0\\"\\nnb = \\"0.1.2\\"\\nembedded-hal = \\"0.2.3\\"\\n\\n[dependencies.arduino-hal]\\ngit = \\"https://github.com/rahix/avr-hal\\"\\nrev = \\"7dfa6d322b9df98b2d98afe0e14a97afe0187ac1\\"\\nfeatures = [\\"arduino-uno\\"]\\n\\n# Configure the build for minimal size - AVRs have very little program memory\\n[profile.release]\\npanic = \\"abort\\"\\ncodegen-units = 1\\ndebug = true\\nlto = true\\nopt-level = \\"s\\"\\n"}}');let a="Anonymous maker",r="void setup() {\n  // put your setup code here, to run once:\n\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n\n}\n",l='void setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println("Hello, ESP32!");\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  delay(10); // this speeds up the simulation\n}\n',d='void setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  Serial.println("Hello, STM32!");\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  delay(10); // this speeds up the simulation\n}\n',p='void setup() {\n  // put your setup code here, to run once:\n  Serial1.begin(115200);\n  Serial1.println("Hello, Raspberry Pi Pico!");\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  delay(1); // this speeds up the simulation\n}\n',c='#include <stdio.h>\n#include "freertos/FreeRTOS.h"\n#include "freertos/task.h"\n\nvoid app_main() {\n  printf("Hello, Wokwi!\\n");\n  while (true) {\n    vTaskDelay(1000 / portTICK_PERIOD_MS);\n  }\n}\n',u={blank:{name:"Blank Diagram",readme:'# Blank project\n\nThis is a blank Wokwi project. Please edit this README file and add a description of your project.\n\n## Usage\n\n1. Add parts by clicking the blue "+" button in the diagram editor\n2. Connect parts by dragging wires between them\n3. Click the green play button to start the simulation\n'},"arduino-uno":{name:"Arduino Uno",boardName:"wokwi-arduino-uno",boardId:"uno",sketch:r},"arduino-mega":{name:"Arduino Mega",boardName:"wokwi-arduino-mega",boardId:"mega",sketch:r},"arduino-nano":{name:"Arduino Nano",boardName:"wokwi-arduino-nano",boardId:"nano",sketch:r},attiny85:{name:"ATtiny85",boardName:"wokwi-attiny85",boardId:"tiny",sketch:r},esp32:{name:"ESP32",boardName:"board-esp32-devkit-c-v4",boardId:"esp",sketch:l,defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp32-s2":{name:"ESP32-S2",boardName:"board-esp32-s2-devkitm-1",boardId:"esp",sketch:l.replace("ESP32","ESP32-S2"),defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp32-s3":{name:"ESP32-S3",boardName:"board-esp32-s3-devkitc-1",boardId:"esp",sketch:l.replace("ESP32","ESP32-S3"),defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp32-c3":{name:"ESP32-C3",boardName:"board-esp32-c3-devkitm-1",boardId:"esp",sketch:l.replace("ESP32","ESP32-C3"),defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"micropython-esp32":{name:"MicroPython on ESP32",boardName:"board-esp32-devkit-c-v4",boardId:"esp",boardAttrs:{env:"micropython-20231227-v1.22.0"},sketchName:"main.py",sketch:'print("Hello, ESP32!")\n',defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"micropython-esp32-c3":{name:"MicroPython on ESP32-C3",boardName:"board-esp32-c3-devkitm-1",boardId:"esp",boardAttrs:{env:"micropython-20231227-v1.22.0"},sketchName:"main.py",sketch:'print("Hello, ESP32-C3!")\n',defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"micropython-esp32-s3":{name:"MicroPython on ESP32-S3",boardName:"board-esp32-s3-devkitc-1",boardId:"esp",boardAttrs:{env:"micropython-20231227-v1.22.0",flashSize:"8"},sketchName:"main.py",sketch:'print("Hello, ESP32-S3!")\n',defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"pi-pico":{name:"Raspberry Pi Pico",boardName:"wokwi-pi-pico",boardId:"pico",sketch:p,defaultConnections:[["pico:GP0","$serialMonitor:RX",""],["pico:GP1","$serialMonitor:TX",""]]},"pi-pico-sdk":{name:"Raspberry Pi Pico (SDK)",boardName:"wokwi-pi-pico",boardId:"pico",sketchName:"main.c",sketch:'#include <stdio.h>\n#include "pico/stdlib.h"\n\nint main() {\n  stdio_init_all();\n  while (true) {\n    printf("Hello, Wokwi!\\n");\n    sleep_ms(250);\n  }\n}',boardAttrs:{builder:"pico-sdk"},defaultConnections:[["pico:GP0","$serialMonitor:RX",""],["pico:GP1","$serialMonitor:TX",""]]},"micropython-pi-pico":{name:"MicroPython on Raspberry Pi Pico",boardName:"wokwi-pi-pico",boardId:"pico",boardAttrs:{env:"micropython-20231227-v1.22.0"},sketchName:"main.py",sketch:'import time\ntime.sleep(0.1) # Wait for USB to become ready\n\nprint("Hello, Pi Pico!")\n',defaultConnections:[]},"circuitpython-pi-pico":{name:"CircuitPython on Raspberry Pi Pico",boardName:"wokwi-pi-pico",boardId:"pico",boardAttrs:{env:"circuitpython-8.0.2"},sketchName:"code.py",sketch:'print("Hello, Pi Pico!")\n',defaultConnections:[]},"pi-pico-w":{name:"Raspberry Pi Pico W",boardName:"board-pi-pico-w",boardId:"pico",sketch:p.replace("Pico!","Pico W!"),defaultConnections:[["pico:GP0","$serialMonitor:RX",""],["pico:GP1","$serialMonitor:TX",""]]},"pi-pico-w-sdk":{name:"Raspberry Pi Pico W (SDK)",boardName:"board-pi-pico-w",boardId:"pico",sketchName:"main.c",sketch:'#include <stdio.h>\n#include "pico/stdlib.h"\n#include "pico/cyw43_arch.h"\n\nint main() {\n  stdio_init_all();\n  while (true) {\n    printf("Hello, Wokwi!\\n");\n    sleep_ms(250);\n  }\n}',boardAttrs:{builder:"pico-sdk"},defaultConnections:[["pico:GP0","$serialMonitor:RX",""],["pico:GP1","$serialMonitor:TX",""]]},"micropython-pi-pico-w":{name:"MicroPython on Raspberry Pi Pico W",boardName:"board-pi-pico-w",boardId:"pico",boardAttrs:{env:"micropython-20231227-v1.22.0"},sketchName:"main.py",sketch:'print("Hello, Pi Pico W!")\n',defaultConnections:[]},"st-nucleo-c031c6":{name:"STM32 Nucleo64 C031C6",boardName:"board-st-nucleo-c031c6",boardId:"nucleo",sketch:d,defaultConnections:[["$serialMonitor:TX","nucleo:PA3","",[]],["$serialMonitor:RX","nucleo:PA2","",[]]]},"st-nucleo-l031k6":{name:"STM32 Nucleo64 L031K6",boardName:"board-st-nucleo-l031k6",boardId:"nucleo",sketch:d,defaultConnections:[["$serialMonitor:TX","nucleo:VCP_RX","",[]],["$serialMonitor:RX","nucleo:VCP_TX","",[]]]},franzininho:{name:"Franzininho",boardName:"wokwi-franzininho",boardId:"franzininho",sketch:r},"franzininho-wifi":{name:"Franzininho WiFi (ESP32-S2)",boardName:"board-franzininho-wifi",boardId:"franzininho",sketch:r},"esp-idf-esp32":{name:"ESP-IDF on ESP32",boardName:"board-esp32-devkit-c-v4",boardId:"esp",boardAttrs:{builder:"esp-idf"},sketchName:"main.c",sketch:c,defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp-idf-esp32-c3":{name:"ESP-IDF on ESP32-C3",boardName:"board-esp32-c3-devkitm-1",boardId:"esp",boardAttrs:{builder:"esp-idf"},sketchName:"main.c",sketch:c,defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp-idf-esp32-c6":{name:"ESP-IDF on ESP32-C6",boardName:"board-esp32-c6-devkitc-1",boardId:"esp",boardAttrs:{builder:"esp-idf"},sketchName:"main.c",sketch:c,defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp-idf-esp32-h2":{name:"ESP-IDF on ESP32-H2",boardName:"board-esp32-h2-devkitm-1",boardId:"esp",boardAttrs:{builder:"esp-idf"},sketchName:"main.c",sketch:c,defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp-idf-esp32-s2":{name:"ESP-IDF on ESP32-S2",boardName:"board-esp32-s2-devkitm-1",boardId:"esp",boardAttrs:{builder:"esp-idf"},sketchName:"main.c",sketch:c,defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"esp-idf-esp32-s3":{name:"ESP-IDF on ESP32-S3",boardName:"board-esp32-s3-devkitc-1",boardId:"esp",boardAttrs:{builder:"esp-idf"},sketchName:"main.c",sketch:c,defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]]},"rust-nostd-esp32":{name:"Rust on ESP32 (no_std)",boardName:"board-esp32-devkit-c-v4",boardId:"esp",sketch:t.Yg.D,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal",convertEol:!0},extraFiles:[{name:"Cargo.toml",content:t.Yg.s}]},"rust-nostd-esp32-c3":{name:"Rust on ESP32-C3 (no_std)",boardName:"board-esp32-c3-devkitm-1",boardId:"esp",sketch:t.v3.D,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal",convertEol:!0},extraFiles:[{name:"Cargo.toml",content:t.v3.s}]},"rust-nostd-esp32-s2":{name:"Rust on ESP32-S2 (no_std)",boardName:"board-esp32-s2-devkitm-1",boardId:"esp",sketch:t.Gm.D,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal",convertEol:!0},extraFiles:[{name:"Cargo.toml",content:t.Gm.s}]},"rust-nostd-esp32-s3":{name:"Rust on ESP32-S3 (no_std)",boardName:"board-esp32-s3-devkitc-1",boardId:"esp",sketch:t.Hs.D,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal",convertEol:!0},extraFiles:[{name:"Cargo.toml",content:t.Hs.s}]},"rust-nostd-esp32-rust-board":{name:"Rust on ESP32 Rust Board (no_std)",boardName:"board-esp32-c3-rust-1",boardId:"esp",sketch:t.Im.D,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-esp"},defaultConnections:[["esp:21","$serialMonitor:RX",""],["esp:20","$serialMonitor:TX",""]],serialMonitor:{display:"terminal",convertEol:!0},extraFiles:[{name:"Cargo.toml",content:t.Im.s}]},"rust-esp32":{name:"Rust on ESP32 (std)",boardName:"board-esp32-devkit-c-v4",boardId:"esp",sketch:t.Sw.D,sketchName:"main.rs",boardAttrs:{builder:"rust-std-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:t.Sw.s}]},"rust-esp32-c3":{name:"Rust on ESP32-C3 (std)",boardName:"board-esp32-c3-devkitm-1",boardId:"esp",sketch:t.yV.D,sketchName:"main.rs",boardAttrs:{builder:"rust-std-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:t.yV.s}]},"rust-esp32-s2":{name:"Rust on ESP32-S2 (std)",boardName:"board-esp32-s2-devkitm-1",boardId:"esp",sketch:t.cq.D,sketchName:"main.rs",boardAttrs:{builder:"rust-std-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:t.cq.s}]},"rust-esp32-s3":{name:"Rust on ESP32-S3 (std)",boardName:"board-esp32-s3-devkitc-1",boardId:"esp",sketch:t.U6.D,sketchName:"main.rs",boardAttrs:{builder:"rust-std-esp"},defaultConnections:[["esp:TX","$serialMonitor:RX",""],["esp:RX","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:t.U6.s}]},"rust-esp32-rust-board":{name:"Rust on ESP32 Rust Board (std)",boardName:"board-esp32-c3-rust-1",boardId:"esp",sketch:t._y.D,sketchName:"main.rs",boardAttrs:{builder:"rust-std-esp"},defaultConnections:[["esp:21","$serialMonitor:RX",""],["esp:20","$serialMonitor:TX",""]],serialMonitor:{display:"terminal"},extraFiles:[{name:"Cargo.toml",content:t._y.s}]},"rust-avr-uno":{name:"Rust on Arduino Uno",boardName:"wokwi-arduino-uno",boardId:"uno",sketch:t.xE.D,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-avr"},extraFiles:[{name:"Cargo.toml",content:t.xE.s}]},"rust-avr-mega":{name:"Rust on Arduino Mega",boardName:"wokwi-arduino-mega",boardId:"mega",sketch:t.hP.D,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-avr"},extraFiles:[{name:"Cargo.toml",content:t.hP.s}]},"rust-avr-nano":{name:"Rust on Arduino Nano",boardName:"wokwi-arduino-nano",boardId:"nano",sketch:t.Ui.D,sketchName:"main.rs",boardAttrs:{builder:"rust-nostd-avr"},extraFiles:[{name:"Cargo.toml",content:t.Ui.s}]}};function m(e){var n,s;let o=[{name:"diagram.json",content:function(e){let{boardName:n,boardId:s,boardAttrs:o,defaultConnections:t,serialMonitor:r}=e;return i()({version:1,author:a,editor:"wokwi",parts:s&&n?[{id:s,type:n,attrs:o}]:[],connections:null!=t?t:[],serialMonitor:r},null,2,100)}(e)},...null!==(n=e.extraFiles)&&void 0!==n?n:[]];return e.sketch&&o.unshift({name:null!==(s=e.sketchName)&&void 0!==s?s:"sketch.ino",content:e.sketch}),e.readme&&o.unshift({name:"README.md",content:e.readme}),o}}}]);